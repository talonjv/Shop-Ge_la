import pool from '../config/connectdb.js';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import session from "express-session";
import transporter from '../middleware/mailer.js';
import crypto from 'crypto';

const SECRET_KEY = process.env.JWT_SECRET || "supersecretkey";
let apiLogin = async (req, res) => {
  const { email, password } = req.body;
  if (!email || !password) {
    return res.status(400).json({ message: "H√£y nh·∫≠p email v√† password" });
  }

  try {
    // 1. T√¨m user trong b·∫£ng customers
    let [results] = await pool.query("SELECT * FROM customers WHERE Email = ?", [email]);
    let user = results.length ? results[0] : null;
    let isCustomer = true; // C·ªù ƒë√°nh d·∫•u l√† kh√°ch h√†ng
    // 2. N·∫øu kh√¥ng t√¨m th·∫•y trong customers, th√¨ t√¨m ti·∫øp trong admins
    if (!user) {
      [results] = await pool.query("SELECT * FROM admins WHERE Email = ?", [email]);
      user = results.length ? results[0] : null;
      isCustomer = false; // C·ªù ƒë√°nh d·∫•u l√† admin
    }

    // 3. N·∫øu kh√¥ng th·∫•y ·ªü c·∫£ hai b·∫£ng => 401
    if (!user) {
      return res.status(401).json({ message: "Email ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng" });
    }

    // 4. L·∫•y passwordHash t·ª´ DB
    const storedPassword = user.PasswordHash;
    let isMatch = false;

    // Ki·ªÉm tra bcrypt
    if (storedPassword.startsWith("$2b$") || storedPassword.startsWith("$2a$")) {
      isMatch = await bcrypt.compare(password, storedPassword);
    } else {
      // N·∫øu ch∆∞a m√£ ho√° th√¨ so s√°nh tr·ª±c ti·∫øp
      isMatch = password === storedPassword;
    }

    if (!isMatch) {
      return res.status(401).json({ message: "Email ho·∫∑c m·∫≠t kh·∫©u sai" });
    }

    // 5. X√°c ƒë·ªãnh role (gi·∫£ s·ª≠ customers.role v√† admins.Role)
    // Tu·ª≥ theo c·ªôt c·ªßa b·∫°n, c√≥ th·ªÉ l√† "role" ho·∫∑c "Role"
    let role;
    if (isCustomer) {
      // M·∫∑c ƒë·ªãnh 0 l√† customer, c√≥ th·ªÉ parseInt(user.role) n·∫øu c·ªôt DB l√† `role`
      role = user.role || "Customer";
    } else {
      // M·∫∑c ƒë·ªãnh 1 l√† admin, c·ªôt DB `Role`
      role = user.Role || "Admin";
    }
    // 6. T·∫°o token
    const token = jwt.sign(
      {
        id: isCustomer ? user.CustomerID : user.AdminID,
        email: user.Email,
        role: role,
      },
      "SECRET_KEY", // n√™n d√πng bi·∫øn .env thay cho "SECRET_KEY"
      { expiresIn: "1h" }
    );

    req.session.user = {
      id: isCustomer ? user.CustomerID : user.AdminID,
      fullName: user.FullName,
      email: user.Email,
      phone: user.Phone,
      role: role, // chu·ªói
      profilePicture: user.ProfilePicture
    };

    console.log("üü¢ ƒêƒÉng nh·∫≠p th√†nh c√¥ng:", req.session.user);
    // 8. Tr·∫£ v·ªÅ client
    return res.json({
      message: "ƒêƒÉng nh·∫≠p th√†nh c√¥ng",
      user: req.session.user,
      token: token,
    });

  } catch (error) {
    console.error("‚ùå L·ªói server:", error);
    return res.status(500).json({ message: "L·ªói server", error });
  }
};
let apiLogOut = async (req,res) =>{
  req.session.destroy();
  res.json({ message: "ƒêƒÉng xu·∫•t th√†nh c√¥ng" });
}
let apiCheck = async (req , res) =>{
if (req.session.user) {
    return res.json({ loggedIn: true, user: req.session.user });
  } else {
    return res.json({ loggedIn: false, message: "Ch∆∞a ƒëƒÉng nh·∫≠p" });
  }
}
// api user
const apigetCustomer = async (req, res) => {
  try {
    // pool.query() tr·∫£ v·ªÅ [rows, fields]
    const [results] = await pool.query('SELECT * FROM customers');
    return res.json({ data: results });
  } catch (error) {
    console.error(error);
    return res.status(500).json({ error: 'L·ªói server' });
  }
}
const apigetUpdateCustomer = async (req, res) => {
  const customerId = req.params.id;

  pool.query('SELECT * FROM customers WHERE CustomerID = ?', [customerId], (error, results) => {
    if (error) {
      console.error(error);
      return res.status(500).json({ error: 'L·ªói server' });
    }
    if (results.length === 0) {
      return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y customer' });
    }
    return res.json(results[0]);
  });
}
const apiUpdateCustomer = async (req, res) => {
  const customerId = req.params.id;
  
  // L·∫•y d·ªØ li·ªáu t·ª´ body (tr·ª´ ·∫£nh)
  const { FullName, Email, Phone, PasswordHash, Gender, Address, District, City, ZipCode } = req.body;

  // N·∫øu c√≥ file ·∫£nh m·ªõi, l·∫•y t√™n file
  const ProfilePicture = req.file ? req.file.filename : null;

  // C√¢u l·ªánh SQL c·∫≠p nh·∫≠t
  let sql = `
    UPDATE customers 
    SET FullName = ?, Email = ?, Phone = ?, PasswordHash = ?, Gender = ?, 
        Address = ?, District = ?, City = ?, ZipCode = ?
  `;

  const params = [FullName, Email, Phone, PasswordHash, Gender, Address, District, City, ZipCode];

  // N·∫øu c√≥ ·∫£nh m·ªõi, th√™m v√†o SQL
  if (ProfilePicture) {
    sql += `, ProfilePicture = ?`;
    params.push(ProfilePicture);
  }

  sql += ` WHERE CustomerID = ?`;
  params.push(customerId);

  pool.query(sql, params, (error, result) => {
    if (error) {
      console.error(error);
      return res.status(500).json({ error: "L·ªói server" });
    }
    if (result.affectedRows === 0) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y kh√°ch h√†ng ƒë·ªÉ c·∫≠p nh·∫≠t" });
    }
    return res.json({ message: "C·∫≠p nh·∫≠t th√†nh c√¥ng" });
  });
}
const apidelCustomer = async (req, res) => {
  const customerId = req.params.id;

  pool.query('DELETE FROM customers WHERE CustomerID = ?', [customerId], (error, result) => {
    if (error) {
      console.error(error);
      return res.status(500).json({ error: 'L·ªói server' });
    }
    if (result.affectedRows === 0) {
      return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y customer ƒë·ªÉ x√≥a' });
    }
    return res.json({ message: 'X√≥a th√†nh c√¥ng' });
  });
}
const viewProfile = async (req, res) => {
  try {
    const customerId = req.params.id;

    // Ki·ªÉm tra customerId c√≥ h·ª£p l·ªá kh√¥ng (ch·ªâ cho ph√©p s·ªë)
    if (!customerId || isNaN(customerId)) {
      return res.status(400).json({ error: "ID kh√°ch h√†ng kh√¥ng h·ª£p l·ªá" });
    }

    const sql = "SELECT * FROM customers WHERE CustomerID = ?";
    
    // S·ª≠ d·ª•ng pool v·ªõi promise
    const [rows] = await pool.query(sql, [customerId]);

    if (rows.length === 0) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y kh√°ch h√†ng" });
    }

    let customer = rows[0];

    // X·ª≠ l√Ω ProfilePicture th√†nh URL ƒë·∫ßy ƒë·ªß
    customer.ProfilePicture = customer.ProfilePicture
      ? `http://localhost:2000/image/${customer.ProfilePicture}`
      : `http://localhost:2000/image/default.jpg`; // ·∫¢nh m·∫∑c ƒë·ªãnh n·∫øu null

    res.json(customer); // Tr·∫£ v·ªÅ th√¥ng tin kh√°ch h√†ng
  } catch (error) {
    console.error("L·ªói truy v·∫•n database:", error);
    res.status(500).json({ error: "L·ªói truy v·∫•n database" });
  }
};
const changeProfile = async (req, res) => {
  try {
    // Ki·ªÉm tra request c√≥ nh·∫≠n params & body kh√¥ng
    console.log("üü¢ API nh·∫≠n request:", req.params, req.body);

    // L·∫•y customerId t·ª´ params
    const customerId = req.params.customerId; 
    if (!customerId) {
      return res.status(400).json({ message: "Thi·∫øu customerId!" });
    }

    // L·∫•y d·ªØ li·ªáu t·ª´ body
    const { FullName, Email, Phone, Gender, Address, District } = req.body;
    if (!FullName || !Email || !Phone) {
      return res.status(400).json({ message: "Thi·∫øu d·ªØ li·ªáu c·∫≠p nh·∫≠t!" });
    }

    // Ki·ªÉm tra kh√°ch h√†ng c√≥ t·ªìn t·∫°i kh√¥ng
    const [customer] = await pool.query("SELECT * FROM customers WHERE customerId = ?", [customerId]);
    console.log("üîç Ki·ªÉm tra kh√°ch h√†ng:", customer);

    if (!customer || customer.length === 0) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y kh√°ch h√†ng!" });
    }

    // C·∫≠p nh·∫≠t th√¥ng tin
    const [result] = await pool.query(
      "UPDATE customers SET FullName = ?, Email = ?, Phone = ?, Gender = ?, Address = ?, District = ? WHERE customerId = ?",
      [FullName, Email, Phone, Gender, Address, District, customerId]
    );

    if (result.affectedRows === 0) {
      return res.status(500).json({ message: "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t kh√°ch h√†ng!" });
    }

    console.log("‚úÖ C·∫≠p nh·∫≠t th√†nh c√¥ng!");
    res.json({ message: "C·∫≠p nh·∫≠t th√¥ng tin th√†nh c√¥ng!" });
  } catch (error) {
    console.error("üö® L·ªói c·∫≠p nh·∫≠t kh√°ch h√†ng:", error);
    res.status(500).json({ message: "L·ªói m√°y ch·ªß!" });
  }
};
const changeAvatar = async (req, res) => {
  try {
    const { customerId } = req.params;

    console.log("üì© File nh·∫≠n ƒë∆∞·ª£c:", req.file); // Log th√¥ng tin file
    console.log("üìå Customer ID:", customerId); // Log ID kh√°ch h√†ng

    if (!req.file) {
      return res.status(400).json({ message: "Vui l√≤ng ch·ªçn t·ªáp ·∫£nh!" });
    }

    // Ki·ªÉm tra kh√°ch h√†ng c√≥ t·ªìn t·∫°i kh√¥ng
    const [customer] = await pool.query("SELECT * FROM customers WHERE customerId = ?", [customerId]);
    if (!customer.length) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y kh√°ch h√†ng!" });
    }

    // Ch·ªâ l∆∞u T√äN FILE v√†o database
    const fileName = req.file.filename;
    await pool.query("UPDATE customers SET ProfilePicture = ? WHERE customerId = ?", [fileName, customerId]);

    res.json({ 
      message: "‚úÖ C·∫≠p nh·∫≠t ·∫£nh ƒë·∫°i di·ªán th√†nh c√¥ng!", 
      ProfilePicture: fileName  // Tr·∫£ v·ªÅ ch·ªâ t√™n file, kh√¥ng c√≥ localhost
    });
  } catch (error) {
    console.error("‚ùå L·ªói upload ·∫£nh:", error);
    res.status(500).json({ message: "L·ªói m√°y ch·ªß!", error: error.message });
  }
};
// const regisTer = async (req, res) => {
//   try {
//     const { fullName, email, phone, password, gender } = req.body;

//     if (!fullName || !email || !phone || !password || !gender) {
//       return res.status(400).json({ message: "Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin" });
//     }

//     let [existingUsers] = await pool.execute("SELECT * FROM customers WHERE Email = ?", [email]);

//     if (existingUsers.length > 0) {
//       return res.status(400).json({ message: "Email ƒë√£ t·ªìn t·∫°i" });
//     }

//     const hashedPassword = await bcrypt.hash(password, 10);
//     // ƒê∆∞·ªùng d·∫´n ·∫£nh m·∫∑c ƒë·ªãnh trong th∆∞ m·ª•c public/images
//     const defaultAvatar = `db1.png`;

//     const sql = `INSERT INTO customers (FullName, Email, Phone, PasswordHash, Gender, ProfilePicture) 
//                  VALUES (?, ?, ?, ?, ?, ?)`;

//     let [result] = await pool.execute(sql, [fullName, email, phone, hashedPassword, gender, defaultAvatar]);

//     res.status(201).json({ message: "ƒêƒÉng k√Ω th√†nh c√¥ng", userId: result.insertId });

//   } catch (error) {
//     console.error("L·ªói ƒëƒÉng k√Ω:", error);
//     res.status(500).json({ message: "L·ªói server" });
//   }
// };
const regisTer = async (req, res) => {
  try {
    const { fullName, email, phone, password, gender } = req.body;

    // Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
    if (!fullName || !email || !phone || !password || !gender) {
      return res.status(400).json({ message: "Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin" });
    }

    // Ki·ªÉm tra email ƒë√£ t·ªìn t·∫°i ch∆∞a
    let [existingUsers] = await pool.execute(
      "SELECT * FROM customers WHERE Email = ?", 
      [email]
    );
    if (existingUsers.length > 0) {
      return res.status(400).json({ message: "Email ƒë√£ t·ªìn t·∫°i" });
    }

    // M√£ ho√° m·∫≠t kh·∫©u
    const hashedPassword = await bcrypt.hash(password, 10);

    // ·∫¢nh m·∫∑c ƒë·ªãnh
    const defaultAvatar = "ph.jpg";

    // INSERT user m·ªõi, g√°n role = 0
    const sql = `
      INSERT INTO customers (
        FullName, 
        Email, 
        Phone, 
        PasswordHash, 
        Gender, 
        ProfilePicture, 
        role
      ) 
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `;

    let [result] = await pool.execute(sql, [
      fullName, 
      email, 
      phone, 
      hashedPassword, 
      gender, 
      defaultAvatar, 
      0
    ]);

    return res.status(201).json({ 
      message: "ƒêƒÉng k√Ω th√†nh c√¥ng", 
      userId: result.insertId 
    });
  } catch (error) {
    console.error("L·ªói ƒëƒÉng k√Ω:", error);
    return res.status(500).json({ message: "L·ªói server" });
  }
};
const apiOTP = async (req, res) => {
  const { email } = req.body;

  try {
    // Ki·ªÉm tra email c√≥ t·ªìn t·∫°i kh√¥ng
    const [rows] = await pool.query("SELECT * FROM customers WHERE Email = ?", [email]);

    if (rows.length === 0) {
      return res.status(400).json({ message: "Email kh√¥ng t·ªìn t·∫°i trong h·ªá th·ªëng" });
    }

    // T·∫°o OTP 6 ch·ªØ s·ªë
    const otp = crypto.randomInt(100000, 999999).toString();

    // T·∫°o JWT ch·ª©a OTP v√† email, h·∫øt h·∫°n sau 5 ph√∫t
    const otpToken = jwt.sign({ email, otp }, SECRET_KEY, { expiresIn: "10m" });


    // G·ª≠i email ch·ª©a OTP Token
    await transporter.sendMail({
      from: process.env.EMAIL_USER,
      to: email,
      subject: "M√£ x√°c th·ª±c OTP - ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u",
      text: `M√£ OTP c·ªßa b·∫°n l√†: ${otp}. OTP n√†y s·∫Ω h·∫øt h·∫°n sau 5 ph√∫t. 
      ƒê·ªÉ x√°c th·ª±c, h√£y g·ª≠i OTP k√®m theo token n√†y: ${otpToken}`,
    });

    res.json({ message: "OTP ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email c·ªßa b·∫°n", otpToken });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "L·ªói h·ªá th·ªëng" });
  }
}
const resetPassword = async (req, res) => {
  const { email, otp, otpToken } = req.body;

  try {
    // Gi·∫£i m√£ JWT ƒë·ªÉ l·∫•y OTP
    let decoded;
    try {
      decoded = jwt.verify(otpToken, SECRET_KEY);
    } catch (err) {
      return res.status(400).json({ message: "OTP ƒë√£ h·∫øt h·∫°n ho·∫∑c kh√¥ng h·ª£p l·ªá" });
    }

    // Ki·ªÉm tra email c√≥ kh·ªõp v·ªõi email trong token kh√¥ng
    if (decoded.email !== email) {
      return res.status(400).json({ message: "Email kh√¥ng h·ª£p l·ªá" });
    }

    // Ki·ªÉm tra OTP c√≥ kh·ªõp kh√¥ng
    if (decoded.otp !== otp) {
      return res.status(400).json({ message: "OTP kh√¥ng h·ª£p l·ªá" });
    }

    // T·∫°o m·∫≠t kh·∫©u m·ªõi ng·∫´u nhi√™n
    const newPassword = crypto.randomBytes(6).toString("hex");
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    // C·∫≠p nh·∫≠t m·∫≠t kh·∫©u m·ªõi trong database
    await pool.query("UPDATE customers SET PasswordHash = ? WHERE Email = ?", [hashedPassword, email]);

    // G·ª≠i m·∫≠t kh·∫©u m·ªõi qua email
    await transporter.sendMail({
      from: process.env.EMAIL_USER,
      to: email,
      subject: "M·∫≠t kh·∫©u m·ªõi c·ªßa b·∫°n",
      text: `M·∫≠t kh·∫©u m·ªõi c·ªßa b·∫°n l√†: ${newPassword}. Vui l√≤ng ƒëƒÉng nh·∫≠p v√† ƒë·ªïi m·∫≠t kh·∫©u ngay!`,
    });

    res.json({ message: "M·∫≠t kh·∫©u m·ªõi ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email c·ªßa b·∫°n" });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "L·ªói h·ªá th·ªëng" });
  }
};
const reVenueDaily = async (req, res) =>{
  try {
    const [rows] = await pool.query(
      `SELECT DATE(CreatedAt) as date, SUM(TotalAmount) as revenue 
       FROM orders WHERE OrderStatus != 'da_huy' 
       GROUP BY DATE(CreatedAt) ORDER BY date;`
    );
    res.json(rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
}
const reVenueMonthly = async (req, res) =>{
   try {
    const [rows] = await pool.query(
      `SELECT YEAR(CreatedAt) as year, MONTH(CreatedAt) as month, SUM(TotalAmount) as revenue 
       FROM orders WHERE OrderStatus != 'da_huy' 
       GROUP BY year, month ORDER BY year, month;`
    );
    res.json(rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
}
const reVenueQuarterly = async (req, res) =>{
      try {
    const [rows] = await pool.query(
      `SELECT YEAR(CreatedAt) as year, QUARTER(CreatedAt) as quarter, SUM(TotalAmount) as revenue 
       FROM orders WHERE OrderStatus != 'da_huy' 
       GROUP BY year, quarter ORDER BY year, quarter;`
    );
    res.json(rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
}

const apiSetting = async (req, res) => {
  try {
    if (req.fileValidationError) {
      return res.status(400).json({ error: req.fileValidationError });
    }

    const { linkFB, shopname, linkIG } = req.body;
    const bannerFiles = req.files?.banner || [];
    const slideFiles = req.files?.slide || [];

    // L·∫•y t√™n file (filename) thay v√¨ full path
    const bannerFileName = bannerFiles.length > 0 ? bannerFiles[0].filename : null;
    const slideFileNames = slideFiles.map(file => file.filename);

    const conn = await pool.getConnection();
    console.log("Inserting:", {
      banner: bannerFileName,
      slide: JSON.stringify(slideFileNames),
      linkFB,
      shopname,
      linkIG
    });

    const [result] = await conn.query(
      `INSERT INTO setting (banner, slide, linkFB, shopname, linkIG)
       VALUES (?, ?, ?, ?, ?)`,
      [
        bannerFileName,
        slideFileNames.length > 0 ? JSON.stringify(slideFileNames) : null,
        linkFB || null,
        shopname || null,
        linkIG || null,
      ]
    );
    conn.release();

    return res.json({
      message: "T·∫°o setting th√†nh c√¥ng",
      settingID: result.insertId,
    });
  } catch (error) {
    console.error("Error in apiSetting:", error);
    return res.status(500).json({ error: "L·ªói khi t·∫°o setting" });
  }
};

 const getSetting = async (req, res) => {
  try {
    const conn = await pool.getConnection();
    const [rows] = await conn.query("SELECT * FROM setting");
    conn.release();

    const data = rows.map(row => {
      let slideArray = [];
      if (row.slide) {
        try {
          slideArray = JSON.parse(row.slide);
        } catch (e) {
          console.error(`Error parsing slide for settingID ${row.settingID}:`, e);
          slideArray = [];
        }
      }
      return {
        settingID: row.settingID,
        Banner: row.banner,
        Slide: slideArray,
        linkFB: row.linkFB,
        Shopname: row.shopname,
        linkIG: row.linkIG,
      };
    });

    return res.json(data);
  } catch (error) {
    console.error("Error in getSetting:", error);
    return res.status(500).json({ error: "L·ªói khi l·∫•y danh s√°ch setting" });
  }
};
const apiGetSetById = async (req, res) => {
  try {
    const { id } = req.params;
    const conn = await pool.getConnection();
    const [rows] = await conn.query("SELECT * FROM setting WHERE settingID = ?", [id]);
    conn.release();

    if (rows.length === 0) {
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y setting" });
    }

    const setting = rows[0];
    let slideArray = [];
    if (setting.slide) {
      try {
        slideArray = JSON.parse(setting.slide);
      } catch (e) {
        console.error(`Error parsing slide for settingID ${setting.settingID}:`, e);
        slideArray = [];
      }
    }

    return res.json({
      settingID: setting.settingID,
      banner: setting.banner,
      slide: slideArray,
      linkFB: setting.linkFB,
      shopname: setting.shopname,
      linkIG: setting.linkIG,
    });
  } catch (error) {
    console.error("Error in apiGetSetById:", error);
    return res.status(500).json({ error: "L·ªói khi l·∫•y setting" });
  }
};
const apiUpdateseting = async (req, res) => {
  try {
    if (req.fileValidationError) {
      return res.status(400).json({ error: req.fileValidationError });
    }
    const { id } = req.params;
    const { linkFB, shopname, linkIG } = req.body;
    const bannerFiles = req.files?.banner || [];
    const slideFiles = req.files?.slide || [];

    // S·ª≠ d·ª•ng filename ƒë·ªÉ l∆∞u t√™n file m·ªõi
    const newBannerFileName = bannerFiles.length > 0 ? bannerFiles[0].filename : null;
    const newSlideFileNames = slideFiles.map(file => file.filename);

    const conn = await pool.getConnection();
    const [rows] = await conn.query("SELECT * FROM setting WHERE settingID = ?", [id]);
    if (rows.length === 0) {
      conn.release();
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y setting" });
    }
    const oldSetting = rows[0];
    const oldBanner = oldSetting.banner;
    const oldSlide = oldSetting.slide ? JSON.parse(oldSetting.slide) : [];

    let finalBanner = oldBanner;
    if (newBannerFileName) {
      // N·∫øu c·∫ßn x√≥a file c≈© v·∫≠t l√Ω, b·∫°n c√≥ th·ªÉ l·∫•y ƒë∆∞·ªùng d·∫´n ƒë·∫ßy ƒë·ªß d·ª±a v√†o t√™n file (n·∫øu l∆∞u file theo ƒë∆∞·ªùng d·∫´n c·ªë ƒë·ªãnh)
      // V√≠ d·ª•: ƒë∆∞·ªùng d·∫´n upload: appRoot + "/src/public/image/"
      const oldBannerPath = oldBanner ? `src/public/image/${oldBanner}` : null;
      if (oldBannerPath && fs.existsSync(oldBannerPath)) {
        fs.unlinkSync(oldBannerPath);
      }
      finalBanner = newBannerFileName;
    }

    let finalSlide = oldSlide;
    if (newSlideFileNames.length > 0) {
      oldSlide.forEach(fileName => {
        const oldSlidePath = `src/public/image/${fileName}`;
        if (fs.existsSync(oldSlidePath)) {
          fs.unlinkSync(oldSlidePath);
        }
      });
      finalSlide = newSlideFileNames;
    }

    await conn.query(
      `UPDATE setting
       SET banner = ?, slide = ?, linkFB = ?, shopname = ?, linkIG = ?
       WHERE settingID = ?`,
      [
        finalBanner,
        finalSlide.length > 0 ? JSON.stringify(finalSlide) : null,
        linkFB || null,
        shopname || null,
        linkIG || null,
        id,
      ]
    );
    conn.release();

    return res.json({ message: "C·∫≠p nh·∫≠t setting th√†nh c√¥ng" });
  } catch (error) {
    console.error("Error in apiUpdateseting:", error);
    return res.status(500).json({ error: "L·ªói khi c·∫≠p nh·∫≠t setting" });
  }
};

const apiDeletesetting = async (req, res) => {
  try {
    const { id } = req.params;
    const conn = await pool.getConnection();
    const [rows] = await conn.query("SELECT * FROM setting WHERE settingID = ?", [id]);
    if (rows.length === 0) {
      conn.release();
      return res.status(404).json({ error: "Kh√¥ng t√¨m th·∫•y setting" });
    }

    const setting = rows[0];
    const banner = setting.banner;
    let slide = [];
    if (setting.slide) {
      try {
        slide = JSON.parse(setting.slide);
      } catch (e) {
        console.error(`Error parsing slide for settingID ${setting.settingID}:`, e);
      }
    }

    await conn.query("DELETE FROM setting WHERE settingID = ?", [id]);
    conn.release();

    if (banner && fs.existsSync(banner)) {
      fs.unlinkSync(banner);
    }
    slide.forEach(filePath => {
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
      }
    });

    return res.json({ message: "X√≥a setting th√†nh c√¥ng" });
  } catch (error) {
    console.error("Error in apiDeletesetting:", error);
    return res.status(500).json({ error: "L·ªói khi x√≥a setting" });
  }
};


  const createAdmin = async (req, res) =>{
    try {
    const { FullName, Email, Phone, PasswordHash, AccessLevel, Role } = req.body;
    let profilePicPath = null;

    // N·∫øu c√≥ file upload, l∆∞u t√™n file v√†o bi·∫øn profilePicPath
    if (req.file) {
      profilePicPath = req.file.filename; 
    }

    const sql = `
      INSERT INTO admins 
      (FullName, Email, Phone, PasswordHash, AccessLevel, ProfilePicture, Role, CreatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, NOW())
    `;
    const [result] = await pool.query(sql, [
      FullName,
      Email,
      Phone,
      PasswordHash,
      AccessLevel,
      profilePicPath,
      Role,
    ]);

    res.json({ success: true, insertedId: result.insertId });
  } catch (error) {
    console.error(error);
    res.status(500).json({ success: false, error: 'Server error' });
  }
  }
  const getAdmin = async (req , res) =>{
       try {
    const [rows] = await pool.query('SELECT * FROM admins');
    res.json(rows);
  } catch (error) {
    console.error(error);
    res.status(500).json({ success: false, error: 'Server error' });
  }
  }
  const getAdminByID = async (req,res) =>{
    try {
    const [rows] = await pool.query('SELECT * FROM admins WHERE AdminID = ?', [req.params.id]);
    if (rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Admin not found' });
    }
    res.json(rows[0]);
  } catch (error) {
    console.error(error);
    res.status(500).json({ success: false, error: 'Server error' });
  }
  }
  const updateAdmin = async (req,res) =>{
      try {
    const { FullName, Email, Phone, PasswordHash, AccessLevel, Role } = req.body;
    let profilePicPath = null;

    if (req.file) {
      profilePicPath = req.file.filename;
    }

    // N·∫øu c√≥ file m·ªõi, c·∫≠p nh·∫≠t ProfilePicture, n·∫øu kh√¥ng th√¨ gi·ªØ nguy√™n
    if (profilePicPath) {
      const sqlUpdate = `
        UPDATE admins SET
          FullName = ?, 
          Email = ?, 
          Phone = ?, 
          PasswordHash = ?,
          AccessLevel = ?, 
          ProfilePicture = ?, 
          Role = ?
        WHERE AdminID = ?
      `;
      await pool.query(sqlUpdate, [
        FullName,
        Email,
        Phone,
        PasswordHash,
        AccessLevel,
        profilePicPath,
        Role,
        req.params.id,
      ]);
    } else {
      // Kh√¥ng upload file m·ªõi => kh√¥ng c·∫≠p nh·∫≠t ProfilePicture
      const sqlUpdateNoFile = `
        UPDATE admins SET
          FullName = ?, 
          Email = ?, 
          Phone = ?, 
          PasswordHash = ?,
          AccessLevel = ?, 
          Role = ?
        WHERE AdminID = ?
      `;
      await pool.query(sqlUpdateNoFile, [
        FullName,
        Email,
        Phone,
        PasswordHash,
        AccessLevel,
        Role,
        req.params.id,
      ]);
    }

    res.json({ success: true });
  } catch (error) {
    console.error(error);
    res.status(500).json({ success: false, error: 'Server error' });
  }
  }
  const deleteAdmin = async (req , res) =>{
    try {
    await pool.query('DELETE FROM admins WHERE AdminID = ?', [req.params.id]);
    res.json({ success: true });
  } catch (error) {
    console.error(error);
    res.status(500).json({ success: false, error: 'Server error' });
  }
  }

export default { 
  apiLogin,regisTer,apiLogOut,
  apiCheck,apiOTP,resetPassword,
  viewProfile,changeProfile,changeAvatar
  ,apigetCustomer,apigetUpdateCustomer 
  ,apiUpdateCustomer,apidelCustomer,
  reVenueDaily,reVenueMonthly,reVenueQuarterly,
  apiSetting,getSetting,apiGetSetById,apiUpdateseting
  ,apiDeletesetting,createAdmin,getAdmin
  ,getAdminByID ,updateAdmin,deleteAdmin
  
 };

